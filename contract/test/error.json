{
    "from": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    "to": "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
    "data": "0x80c5c7d00000000000000000000000002279b7a0a67db372996a5fab50d91eaa73d2ebe60000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001044ba9120f00000000000000000000000090f79bf6eb2c4f870365e785982e1f101e93b906000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000010a741a46278000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000002279b7a0a67db372996a5fab50d91eaa73d2ebe6000000000000000000000000000000000000000000000000000000000000000100000000000000000000000015d34aaf54267db7d7c367839aaf71a00a2c6a6500000000000000000000000000000000000000000000000000000000",
    "accessList": null
}, error={
    "stackTrace": [
        {
            "type": 0,
            "sourceReference": {
                "function": "execFromEntryPoint",
                "contract": "OAuthAccount",
                "sourceName": "contracts/OAuthAccount.sol",
                "sourceContent": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@account-abstraction/contracts/core/BaseAccount.sol\";\nimport \"@account-abstraction/contracts/core/EntryPoint.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"hardhat/console.sol\";\n\ncontract OAuthAccount is BaseAccount {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ECDSA for bytes32;\n\n    event PersonaCreated(\n        address indexed persona,\n        address indexed creator,\n        uint256 mode\n    );\n    event Approval(address indexed spender);\n\n    struct Persona {\n        address creator;\n        EnumerableSet.AddressSet allowTargets;\n        EnumerableSet.AddressSet denyTargets;\n        uint112 balance;\n        uint112 mode; // 0x1:personal, 0x10:sharing,\n    }\n\n    struct PersonaData {\n        address creator;\n        address[] allowTargets;\n        address[] denyTargets;\n        uint112 balance;\n        uint112 mode;\n    }\n\n    IEntryPoint private _entryPoint;\n    address public owner;\n    uint96 private _nonce;\n    uint112 public sharingBalance;\n\n    mapping(address => Persona) private personas;\n    address[] personaAddresses;\n\n    mapping(address => bool) private _approved;\n\n    function nonce() public view virtual override returns (uint256) {\n        return _nonce;\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    event EntryPointChanged(\n        address indexed oldEntryPoint,\n        address indexed newEntryPoint\n    );\n\n    receive() external payable {}\n\n    constructor(IEntryPoint entryPoint_, address owner_) {\n        _entryPoint = entryPoint_;\n        owner = owner_;\n    }\n\n    function transfer(address payable target, uint256 amount) external {\n        _validatePersonaPermission(msg.sender, target, amount);\n        target.transfer(amount);\n    }\n\n    function exec(address target, uint256 value, bytes calldata func) external {\n        _validatePersonaPermission(msg.sender, target, value);\n        _call(target, value, func);\n    }\n\n    function approve(address spender) external {\n        _approved[spender] = true;\n        emit Approval(spender);\n    }\n\n    function createPersona(\n        address signer,\n        address[] calldata allow,\n        address[] calldata deny,\n        uint112 balance\n    ) external {\n        require(\n            msg.sender == owner || msg.sender == address(_entryPoint),\n            \"account: only owner can create persona\"\n        );\n        _createPersona(PersonaData(signer, allow, deny, balance, 0x1));\n    }\n\n    function createSharingPersona(\n        address signer,\n        address[] calldata allow,\n        address[] calldata deny\n    ) external payable {\n        require(\n            _approved[msg.sender],\n            \"account: only owner can create persona\"\n        );\n        _approved[msg.sender] = false;\n        sharingBalance += uint112(msg.value);\n        _createPersona(\n            PersonaData(signer, allow, deny, uint112(msg.value), 0x10)\n        );\n    }\n\n    function _createPersona(PersonaData memory data) private {\n        Persona storage persona = personas[data.creator];\n        persona.creator = data.creator;\n        persona.mode = data.mode;\n        for (uint256 i = 0; i < data.allowTargets.length; i++) {\n            persona.allowTargets.add(data.allowTargets[i]);\n        }\n        for (uint256 i = 0; i < data.denyTargets.length; i++) {\n            persona.denyTargets.add(data.denyTargets[i]);\n        }\n        persona.balance = data.balance;\n        personaAddresses.push(data.creator);\n        emit PersonaCreated(data.creator, data.creator, persona.mode);\n    }\n\n    function execFromEntryPoint(\n        address target,\n        uint256 value,\n        bytes calldata func\n    ) external {\n        _requireFromEntryPoint();\n        _call(target, value, func);\n    }\n\n    function parseCalldata(\n        bytes memory data\n    ) public pure returns (bytes4 funcHash, address target, uint256 value) {\n        assembly {\n            funcHash := mload(add(data, 32))\n            target := mload(add(data, 36))\n            value := mload(add(data, 68))\n        }\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    function _validatePersonaPermission(\n        address personaAddress,\n        address target,\n        uint256 value\n    ) internal virtual {\n        Persona storage persona = personas[personaAddress];\n\n        bool isAllow = persona.allowTargets.contains(target) ||\n            persona.allowTargets.length() == 0; // Empty allowTargets is All Allow\n        bool isDeny = persona.denyTargets.contains(target) ||\n            persona.denyTargets.length() == 0; // Empty denyTargets is All Deny\n\n        require(\n            (isAllow && !isDeny) ||\n                (isAllow && persona.denyTargets.length() == 0) ||\n                tx.origin == address(0),\n            \"account: wrong signature\"\n        );\n\n        uint256 myBalance = address(this).balance;\n\n        require(persona.mode != 0, \"account: not a persona\");\n        require(\n            myBalance > value &&\n                (persona.mode == 0x10 || myBalance - value >= sharingBalance),\n            \"account: personal balance is not enougth\"\n        );\n        require(\n            persona.balance >= value && myBalance >= value,\n            \"account: persona balance is not enougth\"\n        );\n        persona.balance -= uint112(value);\n\n        if (persona.mode == 0x10) {\n            sharingBalance -= uint112(value);\n        }\n    }\n\n    function _validateAndUpdateNonce(\n        UserOperation calldata userOp\n    ) internal override {\n        require(_nonce++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address\n    ) internal virtual override returns (uint256 deadline) {\n        //Todo Require check funcHash\n\n        //TODO: check validate\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address recoverd = hash.recover(userOp.signature);\n        (bytes4 funcHash, address target, uint256 value) = parseCalldata(\n            userOp.callData\n        );\n\n        if (recoverd == owner) {\n            return 0;\n        }\n\n        require(funcHash == 0x80c5c7d0, \"account: invalid funcHash\");\n\n        _validatePersonaPermission(recoverd, target, value);\n\n        return 0;\n    }\n\n    function _updateEntryPoint(address newEntryPoint) internal override {\n        emit EntryPointChanged(address(_entryPoint), newEntryPoint);\n        _entryPoint = IEntryPoint(payable(newEntryPoint));\n    }\n\n    function totalPersona() external view returns (uint256) {\n        return personaAddresses.length;\n    }\n\n    function getPersona(\n        address personaAddress\n    ) external view returns (PersonaData memory) {\n        Persona storage persona = personas[personaAddress];\n        return\n            PersonaData(\n                persona.creator,\n                persona.allowTargets.values(),\n                persona.denyTargets.values(),\n                persona.balance,\n                persona.mode\n            );\n    }\n\n    function getPersonaByIndex(\n        uint256 index\n    ) external view returns (address, PersonaData memory) {\n        address personaAddress = personaAddresses[index];\n        Persona storage persona = personas[personaAddress];\n\n        return (\n            personaAddress,\n            PersonaData(\n                personaAddress,\n                persona.allowTargets.values(),\n                persona.denyTargets.values(),\n                persona.balance,\n                persona.mode\n            )\n        );\n    }\n}\n",
                "line": 132,
                "range": [
                    3905,
                    3931
                ]
            },
            "functionType": 1
        },
        {
            "type": 4,
            "sourceReference": {
                "function": "_call",
                "contract": "OAuthAccount",
                "sourceName": "contracts/OAuthAccount.sol",
                "sourceContent": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@account-abstraction/contracts/core/BaseAccount.sol\";\nimport \"@account-abstraction/contracts/core/EntryPoint.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"hardhat/console.sol\";\n\ncontract OAuthAccount is BaseAccount {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ECDSA for bytes32;\n\n    event PersonaCreated(\n        address indexed persona,\n        address indexed creator,\n        uint256 mode\n    );\n    event Approval(address indexed spender);\n\n    struct Persona {\n        address creator;\n        EnumerableSet.AddressSet allowTargets;\n        EnumerableSet.AddressSet denyTargets;\n        uint112 balance;\n        uint112 mode; // 0x1:personal, 0x10:sharing,\n    }\n\n    struct PersonaData {\n        address creator;\n        address[] allowTargets;\n        address[] denyTargets;\n        uint112 balance;\n        uint112 mode;\n    }\n\n    IEntryPoint private _entryPoint;\n    address public owner;\n    uint96 private _nonce;\n    uint112 public sharingBalance;\n\n    mapping(address => Persona) private personas;\n    address[] personaAddresses;\n\n    mapping(address => bool) private _approved;\n\n    function nonce() public view virtual override returns (uint256) {\n        return _nonce;\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    event EntryPointChanged(\n        address indexed oldEntryPoint,\n        address indexed newEntryPoint\n    );\n\n    receive() external payable {}\n\n    constructor(IEntryPoint entryPoint_, address owner_) {\n        _entryPoint = entryPoint_;\n        owner = owner_;\n    }\n\n    function transfer(address payable target, uint256 amount) external {\n        _validatePersonaPermission(msg.sender, target, amount);\n        target.transfer(amount);\n    }\n\n    function exec(address target, uint256 value, bytes calldata func) external {\n        _validatePersonaPermission(msg.sender, target, value);\n        _call(target, value, func);\n    }\n\n    function approve(address spender) external {\n        _approved[spender] = true;\n        emit Approval(spender);\n    }\n\n    function createPersona(\n        address signer,\n        address[] calldata allow,\n        address[] calldata deny,\n        uint112 balance\n    ) external {\n        require(\n            msg.sender == owner || msg.sender == address(_entryPoint),\n            \"account: only owner can create persona\"\n        );\n        _createPersona(PersonaData(signer, allow, deny, balance, 0x1));\n    }\n\n    function createSharingPersona(\n        address signer,\n        address[] calldata allow,\n        address[] calldata deny\n    ) external payable {\n        require(\n            _approved[msg.sender],\n            \"account: only owner can create persona\"\n        );\n        _approved[msg.sender] = false;\n        sharingBalance += uint112(msg.value);\n        _createPersona(\n            PersonaData(signer, allow, deny, uint112(msg.value), 0x10)\n        );\n    }\n\n    function _createPersona(PersonaData memory data) private {\n        Persona storage persona = personas[data.creator];\n        persona.creator = data.creator;\n        persona.mode = data.mode;\n        for (uint256 i = 0; i < data.allowTargets.length; i++) {\n            persona.allowTargets.add(data.allowTargets[i]);\n        }\n        for (uint256 i = 0; i < data.denyTargets.length; i++) {\n            persona.denyTargets.add(data.denyTargets[i]);\n        }\n        persona.balance = data.balance;\n        personaAddresses.push(data.creator);\n        emit PersonaCreated(data.creator, data.creator, persona.mode);\n    }\n\n    function execFromEntryPoint(\n        address target,\n        uint256 value,\n        bytes calldata func\n    ) external {\n        _requireFromEntryPoint();\n        _call(target, value, func);\n    }\n\n    function parseCalldata(\n        bytes memory data\n    ) public pure returns (bytes4 funcHash, address target, uint256 value) {\n        assembly {\n            funcHash := mload(add(data, 32))\n            target := mload(add(data, 36))\n            value := mload(add(data, 68))\n        }\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    function _validatePersonaPermission(\n        address personaAddress,\n        address target,\n        uint256 value\n    ) internal virtual {\n        Persona storage persona = personas[personaAddress];\n\n        bool isAllow = persona.allowTargets.contains(target) ||\n            persona.allowTargets.length() == 0; // Empty allowTargets is All Allow\n        bool isDeny = persona.denyTargets.contains(target) ||\n            persona.denyTargets.length() == 0; // Empty denyTargets is All Deny\n\n        require(\n            (isAllow && !isDeny) ||\n                (isAllow && persona.denyTargets.length() == 0) ||\n                tx.origin == address(0),\n            \"account: wrong signature\"\n        );\n\n        uint256 myBalance = address(this).balance;\n\n        require(persona.mode != 0, \"account: not a persona\");\n        require(\n            myBalance > value &&\n                (persona.mode == 0x10 || myBalance - value >= sharingBalance),\n            \"account: personal balance is not enougth\"\n        );\n        require(\n            persona.balance >= value && myBalance >= value,\n            \"account: persona balance is not enougth\"\n        );\n        persona.balance -= uint112(value);\n\n        if (persona.mode == 0x10) {\n            sharingBalance -= uint112(value);\n        }\n    }\n\n    function _validateAndUpdateNonce(\n        UserOperation calldata userOp\n    ) internal override {\n        require(_nonce++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address\n    ) internal virtual override returns (uint256 deadline) {\n        //Todo Require check funcHash\n\n        //TODO: check validate\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address recoverd = hash.recover(userOp.signature);\n        (bytes4 funcHash, address target, uint256 value) = parseCalldata(\n            userOp.callData\n        );\n\n        if (recoverd == owner) {\n            return 0;\n        }\n\n        require(funcHash == 0x80c5c7d0, \"account: invalid funcHash\");\n\n        _validatePersonaPermission(recoverd, target, value);\n\n        return 0;\n    }\n\n    function _updateEntryPoint(address newEntryPoint) internal override {\n        emit EntryPointChanged(address(_entryPoint), newEntryPoint);\n        _entryPoint = IEntryPoint(payable(newEntryPoint));\n    }\n\n    function totalPersona() external view returns (uint256) {\n        return personaAddresses.length;\n    }\n\n    function getPersona(\n        address personaAddress\n    ) external view returns (PersonaData memory) {\n        Persona storage persona = personas[personaAddress];\n        return\n            PersonaData(\n                persona.creator,\n                persona.allowTargets.values(),\n                persona.denyTargets.values(),\n                persona.balance,\n                persona.mode\n            );\n    }\n\n    function getPersonaByIndex(\n        uint256 index\n    ) external view returns (address, PersonaData memory) {\n        address personaAddress = personaAddresses[index];\n        Persona storage persona = personas[personaAddress];\n\n        return (\n            personaAddress,\n            PersonaData(\n                personaAddress,\n                persona.allowTargets.values(),\n                persona.denyTargets.values(),\n                persona.balance,\n                persona.mode\n            )\n        );\n    }\n}\n",
                "line": 149,
                "range": [
                    4459,
                    4497
                ]
            },
            "message": {
                "value": {
                    "type": "Buffer",
                    "data": []
                }
            },
            "isInvalidOpcodeError": false
        }
    ],
    "data": "0x"
}, code=UNPREDICTABLE_GAS_LIMIT, version=providers/5.7.2)